# 程序结构

## 2.2 声明

Go 语言主要有四种类型的声明语句：var、const、type 和 func，分别对应变量、常量、类型和函数实体对象的声明。

一个 Go 语言编写的程序对应一个或多个以 .go 为文件后缀名的源文件。每个源文件中以包的声明语句开始，说明该源文件是属于哪个包。包声明语句之后是 import 语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要（译注：函数内部的名字则必须先声明之后才能使用）。

## 2.3 变量

零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在 Go 语言中不存在未初始化的变量。

初始化表达式可以是字面量或任意的表达式。在包级别声明的变量会在 main 入口函数执行前完成初始化（§2.6.2），局部变量将在声明语句被执行到的时候完成初始化。

### 2.3.1 简短变量声明

在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“name := expression”形式声明变量，变量的类型根据表达式来自动推导。下面是 lissajous 函数中的三个简短变量声明语句（§1.4）：

```go
anim := gif.GIF{LoopCount: nframes}
freq := rand.Float64() * 3.0
t := 0.0
```

因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。var 形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。

这里有一个比较微妙的地方：简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域声明过了（§2.7），那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。

在下面的代码中，第一个语句声明了 in 和 err 两个变量。在第二个语句只声明了 out 一个变量，然后对已经声明的 err 进行了赋值操作。

```go
in, err := os.Open(infile)
// ...
out, err := os.Create(outfile)
```

简短变量声明语句中必须至少要声明一个新的变量，下面的代码将不能编译通过：

```go
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) // compile error: no new variables
```

解决的方法是第二个简短变量声明语句改用普通的多重赋值语句。

简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。

### 2.3.2 指针

在 Go 语言中，返回函数中局部变量的地址也是安全的。例如下面的代码，调用 f 函数时创建局部变量 v，在局部变量地址被返回之后依然有效，因为指针 p 依然引用这个变量。

```go
var p = f()

func f() *int {
    v := 1
    return &v
}
```

每次调用 f 函数都将返回不同的结果：

```go
fmt.Println(f() == f()) // "false"
```

### 2.3.3 new 函数

另一个创建变量的方法是调用内建的 new 函数。表达式 `new(T)` 将创建一个 T 类型的匿名变量，初始化为 T 类型的零值，然后返回变量地址，返回的指针类型为 `*T`。

```go
p := new(int)   // p, *int 类型, 指向匿名的 int 变量
fmt.Println(*p) // "0"
*p = 2          // 设置 int 匿名变量的值为 2
fmt.Println(*p) // "2"
```

用 new 创建变量和普通变量声明语句方式创建变量没有什么区别（注意和 C/C++ 使用 new 操作符在堆上空间分配变量内存不同）。除了无需声明一个临时变量的名字外，我们还可以在表达式中使用 `new(T)`。换言之，new 函数类似是一种语法糖，而不是一个新的基础概念。

比如，下面的两个 `newInt` 函数有着相同的行为：

```go
func newInt() *int {
    return new(int)
}

func newInt() *int {
    var dummy int
    return &dummy
}
```

每次调用 new 函数都是返回一个新的变量的地址，因此下面两个地址是不同的：

```go
p := new(int)
q := new(int)
fmt.Println(p == q) // "false"
```

当然也可能有特殊情况：如果两个类型都是空的，也就是说类型的大小是 0，例如 `struct{}` 和 `[0]int`，有可能有相同的地址（依赖具体的语言实现）（译注：请谨慎使用大小为 0 的类型，因为如果类型的大小为 0 的话，可能导致 Go 语言的自动垃圾回收器有不同的行为，具体请查看 `runtime.SetFinalizer` 函数相关文档）。

new 函数使用通常相对比较少，因为对于结构体来说，直接用字面量语法创建新变量的方法会更灵活（§4.4.1）。

由于 new 只是一个预定义的函数，它并不是一个关键字，因此我们可以将 new 名字重新定义为别的类型。例如下面的例子：

```go
func delta(old, new int) int { return new - old }
```

由于 new 被定义为 int 类型的变量名，因此在 delta 函数内部是无法使用内置的 new 函数的。

### 2.3.4 变量的生命周期

变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。

那么 Go 语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。

因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。

编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用 var 还是 new 声明变量的方式决定的（同上，注意与 C/C++ 做区分）。

```go
var global *int

func f() {
    var x int
    x = 1
    global = &x
}

func g() {
    y := new(int)
    *y = 1
}
```

f 函数里的 x 变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的 global 变量找到，虽然它是在函数内部定义的；用 Go 语言的术语说，这个 x 局部变量从函数 f 中逃逸了。相反，当 g 函数返回时，变量 `*y` 将是不可达的，也就是说可以马上被回收的。因此，`*y` 并没有从函数 g 中逃逸，编译器可以选择在栈上分配 `*y` 的存储空间（译注：也可以选择在堆上分配，然后由 Go 语言的 GC 回收这个变量的内存空间），虽然这里用的是 new 方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。

## 2.4 赋值

数值变量也可以支持 ++ 递增和 -- 递减语句（译注：自增和自减是语句，而不是表达式，因此 `x = i++` 之类的表达式是错误的）：

```go
v := 1
v++    // 等价方式 v = v + 1；v 变成 2
v--    // 等价方式 v = v - 1；v 变成 1
```

### 2.4.1 元组赋值

元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。这对于处理有些同时出现在元组赋值语句左右两边的变量很有帮助，例如我们可以这样交换两个变量的值：

```go
x, y = y, x
a[i], a[j] = a[j], a[i]
```

元组赋值也可以使一系列琐碎赋值更加紧凑（译注: 特别是在 for 循环的初始化部分），

```go
i, j, k = 2, 3, 5
```

但如果表达式太复杂的话，应该尽量避免过度使用元组赋值；因为每个变量单独赋值语句的写法可读性会更好。

有些表达式会产生多个值，比如调用一个有多个返回值的函数。当这样一个函数调用出现在元组赋值右边的表达式中时（译注：右边不能再有其它表达式），左边变量的数目必须和右边一致。

```go
f, err = os.Open("foo.txt") // function call returns two values
```

通常，这类函数会用额外的返回值来表达某种错误类型，例如 `os.Open` 是用额外的返回值返回一个 error 类型的错误，还有一些是用来返回布尔值，通常被称为 ok。在稍后我们将看到的三个操作都是类似的用法。如果 map 查找（§4.3）、类型断言（§7.10）或通道接收（§8.4.2）出现在赋值语句的右边，它们都可能会产生两个结果，有一个额外的布尔结果表示操作是否成功：

```go
v, ok = m[key]             // map lookup
v, ok = x.(T)              // type assertion
v, ok = <-ch               // channel receive
```

译注：map查找（§4.3）、类型断言（§7.10）或通道接收（§8.4.2）出现在赋值语句的右边时，并不一定是产生两个结果，也可能只产生一个结果。对于只产生一个结果的情形，map 查找失败时会返回零值，类型断言失败时会发生运行时 panic 异常，通道接收失败时会返回零值（阻塞不算是失败）。例如下面的例子：

```go
v = m[key]                // map查找，失败时返回零值
v = x.(T)                 // type断言，失败时panic异常
v = <-ch                  // 管道接收，失败时返回零值（阻塞不算是失败）

_, ok = m[key]            // map返回2个值
_, ok = mm[""], false     // map返回1个值
_ = mm[""]                // map返回1个值
```

和变量声明一样，我们可以用下划线空白标识符 `_` 来丢弃不需要的值。

```go
_, err = io.Copy(dst, src) // 丢弃字节数
_, ok = x.(T)              // 只检测类型，忽略具体值
```

> [NOTE] 其实这里有些令我感到意外。类似 `m[key]` 这样的调用竟然会根据左侧“接收参数”的数量来判断其调用返回值数量。如果用 C/C++ 视角来看，这个调用是实现了一个重载，但和 C/C++ 机制不同的是，C/C++ 本身是不能通过返回值类型来作为重载条件的。Go 对于左值、右值与函数调用的结合效果，令我有些惊奇。当然，我是 Go 新手，读到这里还不太清楚 Go 是如何实现这样的机制的，后面学习到再感受、再研究。

### 2.4.2 可赋值性

## 2.5 类型

一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。

```go
type 类型名字 底层类型
```

类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用。

> 对于中文汉字，Unicode 标志都作为小写字母处理，因此中文的命名默认不能导出。

为了说明类型声明，我们将不同温度单位分别定义为不同的类型：

- [_Ch02/tempconv0.go_](./Ch02/tempconv0.go)

```go
// Package tempconv performs Celsius and Fahrenheit temperature computations.
package tempconv

import "fmt"

type Celsius float64    // 摄氏温度
type Fahrenheit float64 // 华氏温度

const (
    AbsoluteZeroC Celsius = -273.15 // 绝对零度
    FreezingC     Celsius = 0       // 结冰点温度
    BoilingC      Celsius = 100     // 沸水温度
)

func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }

func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
```

我们在这个包声明了两种类型：Celsius 和 Fahrenheit 分别对应不同的温度单位。它们虽然有着相同的底层类型 float64，但是它们是不同的数据类型，因此它们不可以被相互比较或混在一个表达式运算。刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致的错误；因此需要一个类似 `Celsius(t)` 或 `Fahrenheit(t)` 形式的显式转型操作才能将 `float64` 转为对应的类型。`Celsius(t)` 和 `Fahrenheit(t)` 是类型转换操作，它们并不是函数调用。类型转换不会改变值本身，但是会使它们的语义发生变化。另一方面，`CToF` 和 `FToC` 两个函数则是对不同温度单位下的温度进行换算，它们会返回不同的值。

对于每一个类型 T，都有一个对应的类型转换操作 `T(x)`，用于将 x 转为 T 类型（译注：如果 T 是指针类型，则需要用小括弧包装 T，比如 `(*int)(0)`）。只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。如果 `x` 是可以赋值给 `T` 类型的值，那么 `x` 必然也可以被转为 `T` 类型，但是一般没有这个必要。

数值类型之间的转型也是允许的，并且在字符串和一些特定类型的 slice 之间也是可以转换的，在下一章我们会看到这样的例子。这类转换可能改变值的表现。例如，将一个浮点数转为整数将丢弃小数部分，将一个字符串转为 `[]byte` 类型的 slice 将拷贝一个字符串数据的副本。在任何情况下，运行时不会发生转换失败的错误（译注: 错误只会发生在编译阶段）。

底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持。这意味着，`Celsius` 和 `Fahrenheit` 类型的算术运算行为和底层的 `float64` 类型是一样的，正如我们所期望的那样。

```go
fmt.Printf("%g\n", BoilingC-FreezingC) // "100" °C
boilingF := CToF(BoilingC)
fmt.Printf("%g\n", boilingF-CToF(FreezingC)) // "180" °F
fmt.Printf("%g\n", boilingF-FreezingC)       // compile error: type mismatch
```

比较运算符 `==` 和 `<` 也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型的未命名类型的值之间做比较。但是如果两个值有着不同的类型，则不能直接进行比较：

```go
var c Celsius
var f Fahrenheit
fmt.Println(c == 0)          // "true"
fmt.Println(f >= 0)          // "true"
fmt.Println(c == f)          // compile error: type mismatch
fmt.Println(c == Celsius(f)) // "true"!
```

注意最后那个语句。尽管看起来像函数调用，但是 `Celsius(f)` 是类型转换操作，它并不会改变值，仅仅是改变值的类型而已。测试为真的原因是因为 `c` 和 `f` 都是零值。

一个命名的类型可以提供书写方便，特别是可以避免一遍又一遍地书写复杂类型（译注：例如用匿名的结构体定义变量）。虽然对于像 float64 这种简单的底层类型没有简洁很多，但是如果是复杂的类型将会简洁很多，特别是我们即将讨论的结构体类型。

命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集。我们将在第六章中讨论方法的细节，这里只说些简单用法。

下面的声明语句，Celsius 类型的参数 c 出现在了函数名的前面，表示声明的是 Celsius 类型的一个名叫 String 的方法，该方法返回该类型对象 c 带着°C温度单位的字符串：

```go
func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }
```

许多类型都会定义一个 String 方法，因为当使用 fmt 包的打印方法时，将会优先使用该类型对应的 String 方法返回的结果打印，我们将在 7.1 节讲述。

```go
c := FToC(212.0)
fmt.Println(c.String()) // "100°C"
fmt.Printf("%v\n", c)   // "100°C"; no need to call String explicitly
fmt.Printf("%s\n", c)   // "100°C"
fmt.Println(c)          // "100°C"
fmt.Printf("%g\n", c)   // "100"; does not call String
fmt.Println(float64(c)) // "100"; does not call String
```

## 2.6 包和文件
